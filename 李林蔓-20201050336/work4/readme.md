实验四

实验内容：
熟悉OPENGL，实现填充算法

结果：
![Image text](https://github.com/Bagery001/-/blob/main/%E6%9D%8E%E6%9E%97%E8%94%93-20201050336/work4/%E5%AE%9E%E9%AA%8C4.jpg)

关键代码：
利用Dfs实现简单递归填充。
// 简单深度搜索填充 （四连通）
void DfsFill(int x, int y)
{
	if (x < 0 || y < 0 || x>23 || y>23)
	{
		return;
	}
	if (a[x][y] == 0)
	{
		a[x][y] = 2;
		DfsFill(x - 1, y);
		DfsFill(x + 1, y);
		DfsFill(x, y - 1);
		DfsFill(x, y + 1);
	}
}
扫描线种子填充算法（四连通）
1. 种子点（x,y）入栈。 
2. 栈顶元素（x,y）出栈作为种子点。
3. 从种子点（x,y）开始沿着扫描线向左右两个方向逐个像素进行填充，直到到达边界像素为止。
4. 将上述填充区段的左右端点的横坐标分别记为xleft和xright.
5. 在与当前扫描线相邻的上下两条扫描线的[xleft，xright]范围内进行检查，
看看是否全部为边界像素或已填充像素，若存在着非边界且未填充的像素，那么将该区段的最右端像素作为种子点入栈。

总结：
扫描多边形填充算法的基本原理——在直角坐标系中，假设有一条从左至右的扫描线穿过多边形，从左至右开始计数，与多边形交点为奇数时，开始进入多边形，与多边形交点为偶数时，走出多边形。这样在这相邻配对的奇偶交点间的所有象素都在多边形内。如图，奇数交点a，c，都是进入多边形，偶数交点b，d都是走出多边形，相邻的奇偶交点配对，a，b之间，c，d之间的象素都在多边形内，可见一条扫描线上，与多边形交点个数需要为偶数。依据这样的思路，扫描线从上到下，从左到右依次扫过多边形即可求得多边形所占据的象素。（注意退化情况的处理，也就是扫描线刚好经过顶点或者多边形的边本身就是水平的情况）
